package com.anadathur.elastic.easymapping

import java.io._
import javax.lang.model.element.Modifier
import com.google.gson.Gson
import scala.collection.mutable
import com.squareup.javapoet._

case class Config(packageName: String,
                  outputFolder: File,
                  mappings: Set[File] = Set.empty,
                  verbose: Boolean = false,
                  resources: Map[String, InputStream] = Map.empty) {
  requireNotEmpty(packageName, "Package name cannot be empty")
  requireNotNull(outputFolder)
  require(!(mappings.isEmpty && resources.isEmpty), "Both resource pattern & mapping set cannot be undefined")
  val mappingTypeClass = className(packageName, ClassGenerator.mappingTypeClassName)
  val propertyClassName = className(packageName, ClassGenerator.propertyClassName)

}

private[this] case class MappingFile(name: String, content: Reader)

trait TypeGenerator extends Function[Config, List[TypeSpec]] {
  protected[this] val privFinal = Array(Modifier.PRIVATE, Modifier.FINAL)

}

class MappingToClassGenerator(iterable: Iterable[MappingFile]) extends TypeGenerator {
  private val gson = new Gson()

  override def apply(v1: Config): List[TypeSpec] = {
    iterable.map { mappingFile =>
      gson.fromJson()

    }

    Nil
  }
}


object ClassGenerator {
  val allMappingsClassName = "MappingTypes"
  val mappingTypeClassName = "MappingType"
  val propertyClassName = "MappingTypeProperty"
  val fileComments = "This file was auto generated by easymapping. Please do not modify."

  def writeContent(packageName: String, generator: String => (String, String), dir: File): Unit = {
    val (className, content) = generator(packageName)
    val file = new File(dir, packageName.replaceAllLiterally(".", "/") + "/" + className + ".java")
    println(s"Generating $packageName.$className")
    val os = new FileOutputStream(file)
    os.write(content.getBytes)
    os.close()
  }
}

class ClassGenerator(private[this] val config: Config){
  import ClassGenerator._
  require(config != null, "Config cannot be null")

  private[this] val gson = new Gson()
  private[this] val mappingTypes: mutable.Set[String] = mutable.Set()
  private[this] val privFinal = Array(Modifier.PRIVATE, Modifier.FINAL)
  private[this] val generators: List[TypeGenerator] = new MappingToClassGenerator(mappings) :: new DefaultMappingGen :: Nil


/*
  private[this] def generateJavaMapping(mappingFile: MappingFile): Unit = {
      val mapping: JMap[_, _] = gson.fromJson(mappingFile.content, classOf[JMap[_, _]])
  }

  private[this] def generateOthers(): Unit = {
    def method(name: String, returnType: AnyRef, doc: String = ""): MethodSpec = {
      val builder = MethodSpec.methodBuilder(name).addJavadoc(doc)
      returnType match {
        case clazz: Type    =>    builder.returns(clazz).build()
        case tNme: TypeName => builder.returns(tNme).build()
      }
    }
  }
*/

  private[this] def writeType(spec: TypeSpec): Unit = {
    if (config.verbose) {
      println(s"Generating ${spec.name}")
    }
    JavaFile.builder(config.packageName, spec)
      .addFileComment(fileComments)
      .build()
      .writeTo(config.outputFolder)
  }

  def generate(): Unit = {
    val pkgFolder = new File(config.outputFolder, config.packageName.replaceAllLiterally(".", "/"))
    if (!pkgFolder.exists()) {
      require(pkgFolder.mkdirs(), s"Unable to create dir: $pkgFolder")
    }

    try {
      for (spec <- generators.map(_.apply(config)).flatten) {
        writeType(spec)
      }
    }
    catch {
      case ex: Exception =>
        if (config.verbose) {
          ex.printStackTrace()
        }
        println(s"Error: Unable to generate mappings. Error = ${ex.getMessage}")
        return
    }
  }

  private[this] def mappings: Iterable[MappingFile] = {
    if (config.mappings.nonEmpty) {
      for (file <- config.mappings)
        yield MappingFile(file.getName.replace(".json", ""), new FileReader(file))
    } else {
      for ((name, resource) <- config.resources)
        yield MappingFile(name, new InputStreamReader(resource))
    }
  }
}